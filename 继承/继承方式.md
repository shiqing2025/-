### 原型链继承
原型链继承： 使用原型实现继承时，实质上是**将子类的原型设置为父类的一个实例**， 这样子类的原型就包含了父类的属性和方法，从而实现了继承。
`  Child.prototype = new Parent(); `

- 缺点: 
  - 1. 引用类型的属性被所有实例共享：由于子类的原型是父类的实例，所以父类中的引用类型属性（如数组、对象）会被所有子类实例共享，一个实例修改该属性时，其他实例也会受到影响。
  - 2. 可以向父类构造函数传递参数比较麻烦，需要在子类构造函数中调用父类构造函数。
然而，这样做会导致父类构造函数被调用两次，一次是在子类构造函数中, 另一次是在设置子类原型时(即通过构造函数生成实例时).这可能会导致性能问题和不必要的资源消耗。 


### 构造函数继承
"构造函数继承"（也被称为"经典继承"或"伪经典继承"）的本质是在子类的构造函数中通过调用父类的构造函数并改变其上下文（this指向）来达到继承效果。

在JavaScript中，函数的call和apply方法可以改变函数执行时的上下文，即函数体内this的值。当我们在子类的构造函数中调用Parent.call(this, name)时，实际上是在新创建的子类实例的上下文中执行了父类的构造函数，这样父类的所有属性和方法都会被复制到子类实例中，从而实现了继承。

但这种方式只能继承父类的实例属性和方法，不能继承父类原型上的属性和方法。而且因为属性和方法都是在构造函数中定义的，所以每个实例都会有一份自己的副本，这会导致内存浪费。

这就是构造函数继承的本质。虽然它有一些缺点，但在某些场景下，如需要传递参数，或需要避免引用类型属性被所有实例共享时，可以结合其他继承方式一起使用。


### 组合继承
也称为伪经典继承，这种方式结合了原型链继承和构造函数继承。使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。
组合继承的主要缺点是父类构造函数会被调用两次。一次是在创建子类原型的时候，一次是在子类构造函数内部。这不仅会导致效率降低，还会导致子类原型上面多出许多不必要的属性。


### 原型式继承 
通过一个已有的对象创建一个新对象，并继承已有对象的属性和方法. Object.create(obj {})
原型式继承的优化点主要在于它的简单性和灵活性，适合于某些不需要创建自定义类型的场景
缺点是不能解决引用类型属性共享的问题
> Object.create()的第二个参数与Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。


### 寄生式继承
- 核心思路： 寄生式继承的核心思路是创建一个函数，这个函数接收一个已有的对象作为参数，然后对这个对象进行扩展或增强，最后返回这个增强后的对象。

- 优点：可以在不影响父对象的前提下，对新创建的对象进行额外的修改和增强。
- 缺点：
  - 与构造函数模式类似，每次创建对象都会创建一遍方法，这样就无法实现函数复用
  - 不能解决引用类型属性共享的问题

### 寄生式组合继承
目标: 
  1. 解决引用类型属性共享的问题
  2. 实现函数复用
  3. 旨在解决组合式继承的问题：多次调用构造函数. (组合继承上面两个问题已经解决了) 

寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承原型方法。


### class类继承
ES6的class和extends：ES6引入了基于类的面向对象编程语法，可以使用class和extends super关键字实现继承。
