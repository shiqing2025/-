### 原型链继承
原型链继承： 使用原型实现继承时，实质上是**将子类的原型设置为父类的一个实例**， 这样子类的原型就包含了父类的属性和方法，从而实现了继承。
`  Child.prototype = new Parent(); `

- 缺点: 
  - 1. 引用类型的属性被所有实例共享：由于子类的原型是父类的实例，所以父类中的引用类型属性（如数组、对象）会被所有子类实例共享，一个实例修改该属性时，其他实例也会受到影响。
  - 2. 可以向父类构造函数传递参数比较麻烦，需要在子类构造函数中调用父类构造函数。
然而，这样做会导致父类构造函数被调用两次，一次是在子类构造函数中, 另一次是在设置子类原型时(即通过构造函数生成实例时).这可能会导致性能问题和不必要的资源消耗。 


### 构造函数继承
"构造函数继承"（也被称为"经典继承"或"伪经典继承"）的本质是在子类的构造函数中通过调用父类的构造函数并改变其上下文（this指向）来达到继承效果。

在JavaScript中，函数的call和apply方法可以改变函数执行时的上下文，即函数体内this的值。当我们在子类的构造函数中调用Parent.call(this, name)时，实际上是在新创建的子类实例的上下文中执行了父类的构造函数，这样父类的所有属性和方法都会被复制到子类实例中，从而实现了继承。

但这种方式只能继承父类的实例属性和方法，不能继承父类原型上的属性和方法。而且因为属性和方法都是在构造函数中定义的，所以每个实例都会有一份自己的副本，这会导致内存浪费。

这就是构造函数继承的本质。虽然它有一些缺点，但在某些场景下，如需要传递参数，或需要避免引用类型属性被所有实例共享时，可以结合其他继承方式一起使用。


### 组合继承
也称为伪经典继承，这种方式结合了原型链继承和构造函数继承。使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。
组合继承的主要缺点是父类构造函数会被调用两次。一次是在创建子类原型的时候，一次是在子类构造函数内部。这不仅会导致效率降低，还会导致子类原型上面多出许多不必要的属性。
